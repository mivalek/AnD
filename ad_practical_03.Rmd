---
title: "Practical 3"
author: "Analysing data"
---

<!-- To knit this .Rmd do the following -->

```{r setup_how_to_knit, include=F, eval=F}
remotes::install_github("mivalek/teachR")
teachR::make.sheet("[path to file]/ad_practical03.Rmd", "other", toc_depth = 3)
```


## Today

- Read in and check data
- Basic descriptive statistics
- Descriptive visualisation
- Write-up: Participants

## Guided part

```{r setup_data, echo = F}
set.seed(1)
library(tidyverse)
n <- 427
my_data <- tibble(id = replicate(n, paste(c(sample(LETTERS, 2, T), sample(0:9, 3)), collapse = "")),
                  age = round(abs(rnorm(n, 0, 2)) + 17.3),
                  breakfast = sample(c("sweet", "savoury", "only tea", "only cofee",
                                      "only other drink", "both sweet and savoury", "nothing"),
                                    n, replace = T, prob = c(.32, .14, .05, .21, .07, .11, .1)))
my_data[sample(n, 6), 2] <- NA
my_data[sample(n, 11), 3] <- NA
```

First of all, let's make sure we're all set up:

- Create a new R project in the AD folder, call it week_3
- Log into Canvas and go to this week's practical
- Download the "01_basic_desc.Rmd" file into your project folder
- Open R Studio

### Read in data

Data from the form you filled in in the previous lecture are here: https://...

Anything online is just some sort of file. In this case, it is a "comma-separated values" file, or CSV. We *could* download it to our folder and then read it into R Studio. However, we can also read it directly from the URL like this:

```{r, eval=F}
read_csv("https://...")
```

**Time to think**

Why might it be preferable to read data in from the URL?

Why might it be better to save data on your computer?

The `read_csv()` function comes from the `tidyverse` package. What do we need to do before we can run the command above?

What will the command above do? Is that what we want? If not, what do we need to add to the line?

Let's read the data into R Studio so that we can start working with them.

```{r, eval=F}
library(tidyverse)
my_data <- read_csv("https://...")
```

### First glance

Now that we have our data in R Studio, we should familiarise ourselves with it. Best place to start is often looking at the structure of the data set.

```{r}
my_data %>% str()
```

It's good to set categorical variables to be factors instead of character vectors. Factors are handy for plotting and some statistics.

```{r}
my_data <- my_data %>%
  mutate(id = factor(id), breakfast = factor(breakfast))
my_data %>% str()
```

\ 

Now that basic housekeeping is done, let's look at the roughest summary of our data.

```{r}
my_data %>% summary()
```

As we can see, we have some missing values in the `age` and `breakfast` variables. That's OK, missing data happen. Since `id` was a required variable, we don't need to worry about `NA`s.

\ 

However, `id` should be a unique code so it's good to check if there are no duplicates. The `duplicated()` function takes a vector and returns a vector of `TRUE`s and `FLASE`s of equal length. We expect all values to be `FALSE` (*e.g.,* `id`s are unique).

```{r}
duplicated(c(1, 2, 5)) # unique -> all FALSE
duplicated(c(1, 2, 2)) # not unique -> some TRUE
```

Let's create a column `id_check` and ask for `summary()` again

```{r}
my_data %>%
  mutate(id_check = duplicated(id)) %>%
  summary()
```

Cool, there are only `FALSE`s which means no duplicates!

*Note. *We don't really need the `id_check` column permanently in our data set so we don't need to modify it by doing `my_data <- my_data %>% mutate(...`.

### Basic descriptive stats

With all of this out of the way, we can prepare tibbles of relevant summary statistics. First of all, age:

```{r}
age_desc <- my_data %>%
  summarise(age_mean = mean(age),
            sd_age = sd(age),
            min_age = min(age),
            max_age = max(age),
            na_age = sum(is.na(age)))
age_desc
```

Why are we getting weird results?

What do we need to do to get what we want?

```{r}
age_desc <- my_data %>%
  summarise(mean = mean(age, na.rm = T),
            sd = sd(age, na.rm = T),
            min = min(age, na.rm = T),
            max = max(age, na.rm = T),
            na = sum(is.na(age)))
age_desc
```

We only ever need to report these kinds of numbers to 2 decimal places so let's round things up:

```{r}
age_desc <- age_desc %>% 
  modify(round, 2)
age_desc
```

We can doo all of the above in a single *pipeline*:

```{r}
age_desc <- my_data %>%
  summarise(mean = mean(age, na.rm = T),
            sd = sd(age, na.rm = T),
            min = min(age, na.rm = T),
            max = max(age, na.rm = T),
            na = sum(is.na(age))) %>%
  modify(round, 2)
age_desc
```

This `age_desc` tibble now enables us to report descriptive statistics in text using inline code. For instance, we can just type <code>&#96;r age_desc %>% pull(mean)&#96;</code> in R Markdown and when the file gets generated, it will read `r age_desc %>% pull(mean)`. That's useful, isn't it!

\ 

Let's create another tibble of descriptives, this time with age breakdown by breakfast:

```{r}
brekky_desc <- my_data %>%
  group_by(breakfast) %>%
  summarise(n = n(),
            perc = n()/nrow(my_data) * 100,
            mean_age = mean(age, na.rm = T),
            sd_age = sd(age, na.rm = T)) %>%
  modify_if(is.numeric, round, 2)
brekky_desc
```

The command returns the following warning:

"Factor `breakfast` contains implicit NA, consider using `forcats::fct_explicit_na`"

This is not technically a problem, we can just have a row for `NA` in the tibble. However, using the `fct_explicit_na()` function suggested by the warning creates an additional level `(Missing)` in the `breakfast` variable, instead of the `NA`s. We can use the function inside of `mutate()`:

```{r}
brekky_desc <- my_data %>%
  mutate(breakfast = fct_explicit_na(breakfast)) %>%
  group_by(breakfast) %>%
  summarise(n = n(),
            perc = n()/nrow(my_data) * 100,
            mean_age = mean(age, na.rm = T),
            sd_age = sd(age, na.rm = T)) %>%
  modify_if(is.numeric, round, 2)
brekky_desc
```

I think this looks better and there are also minor advantages of having explicitly labelled missing data when it comes to plotting. More on that later...

\ 

This second descriptive tibble is also quite handy as we can take it and easily convert in into a nice table using the `kable()` function from package `knitr`:

```{r}
library(knitr)
brekky_desc %>% kable()
```

Granted, the table isn't formatted perfectly... Let's do it then!

There are basically only three things we want to edit

1. It would be good to capitalise the first letters in each breakfast option
2. The table header could look better
3. The table should have a caption

With respect to the first point, we could laboriously change the first column of `brekky_desc`. Fortunately, there is a function in the `stringr` package that turns a string into a sentence, *i.e.,* capitalises the first letter:

```{r}
library(stringr)
str_to_sentence("some string we want to edit")
```

We can use this function in `mutate()` to change the first column of our `brekky_desc` tibble:

```{r}
brekky_desc %>%
  mutate(breakfast = str_to_sentence(breakfast))
```

The remaining two edits can be done using arguments to `kable()`, namely `col.names=` and `caption=`. We can use R Markdown within these arguments to get things like subscripts or italics:

```{r}
brekky_desc %>%
  mutate(breakfast = str_to_sentence(breakfast)) %>%
  kable(col.names = c("Breakfast", "*N*", "%", "*M*~age~", "*SD*~age~"),
        caption = "Table 1 *Descriptive statistics by breakfast*")
```

\ 

That's pretty neat, don't you think?

\ 

<div class="warn">
Tables in documents generated from your own R markdown files will look slightly different. That is because we are using our own custom theme for these sheets.
</div>

### Visualisation

While some descriptive statistics and results are best summarised in a table, it is often worth visualising your data using plots. Some plots are great for presenting results to your audience while others are just a tool for you to get a better feel for your data and results. It is neither necessary nor desirable to include every plot you create in your write-up/paper/poster. Only show plots if they add anything of explanatory value to your body text and tables, the rest are for your eyes only (or for the appendix/supplementary materials).

Let's look at a simple histogram of our `age` variable:

```{r, message=T}
my_data %>%
  ggplot(aes(x = age)) +
  geom_histogram()
```

\ 

OK, this histogram gives us a visual representation of the distribution of ages in the sample: The vast majority of participants are 18-19 years old. This is not news as we can read this from the first summary we ran:

```{r}
my_data %>% summary()
```

As you can see the first quartile of `age` is 18 and the third quartile is 19. That means that at least the middle 50% of the sample's age falls within 18 and 19. Seeing the distribution plotted is, however, still useful.

Aesthetically speaking, our histogram isn't that much to look at. Fortunately, with `ggplot()` and some of its extensions, we can customise our plots to death and beyond! The `cowplot` package contains a nice clean theme for publication-style `ggplot()` plots. Let's install it.

```{r, eval=F}
install.packages("cowplot")
```

Once we load it, we can add `theme_cowplot()` to our plot to make it look a little better:

```{r, message=T}
library(cowplot)
my_data %>%
  ggplot(aes(x = age)) +
  geom_histogram() +
  theme_cowplot()
```

Notice that `R` warns us that the histogram plots values by default into 30 bins. In other words, it leaves enough room in the plot for 30 columns. However, we only have 8 distincs ages (17-24). We might as well change the number of bins to 8 using the `bins=` argument inside `geom_histogram()`. While we are at it, we can also change the colour of the outline of the bars (`color=`) and the colour of the bars themselves (`fill=`):

```{r}
library(cowplot)
my_data %>%
  ggplot(aes(x = age)) +
  geom_histogram(bins = 8, color = "black", fill = "grey") +
  theme_cowplot()
```

\ 

That looks way better! The only thing left to do now is give our axes proper labels:

```{r}
library(cowplot)
my_data %>%
  ggplot(aes(x = age)) +
  geom_histogram(bins = 8, color = "black", fill = "grey") +
  labs(x = "Age", y = "Frequency") +
  theme_cowplot()
```

\ 

There, that's one neat plot!

\ 

OK, let's see what we can do with our `breakfast` variable.

Basically the only way of visualising a single categorical variable is using the barchart:

```{r}
my_data %>%
  ggplot(aes(x = breakfast)) +
  geom_bar()
```

Again, we can customise the plot in several ways. Notice that the bars are ordered alphabetically and their labels are the same as the levels of our `breakfast` variable:

```{r}
my_data %>%
  pull(breakfast) %>%
  levels()
```

One thing to do would be to capitalise the labels on the x-axis. We already know how to do this from out table above: use the `str_to_sentence()` function.

Another reasonable edit is to order the levels of the variable according to frequency so that the most popular breakfast option is on one end of the plot and the least popular on the other. To do this, we can add the `fct_infreq()` function to the `mutate()` command:

```{r}
my_data %>%
  mutate(breakfast = str_to_sentence(breakfast),
         breakfast = fct_infreq(breakfast)) %>%
  ggplot(aes(x = breakfast)) +
  geom_bar()
```

*Note* that our two functions inside the `mutate()` commands come before the data are pushed into `ggplot()`. That is because we aren't really changing the plot itself but the `my_data` tibble. We are essentially telling `R` to change the `breakfast` variable in the tibble so that its levels are capitalised and then change it again so that the levels are ordered according to their frequencies.

\ 

Let's tweak the appearance of our plot using what we already know:

```{r}
my_data %>%
  mutate(breakfast = str_to_sentence(breakfast),
         breakfast = fct_infreq(breakfast)) %>%
  ggplot(aes(x = breakfast)) +
  geom_bar(color = "black", fill = "grey") +
  labs(x = "Breakfast", y = "N") +
  theme_cowplot()
```

\ 

As you can see, we have some overlapping labels. That's not great. There are several ways around this issue. For instance, we could rotate the labels 45° to stop them from overlapping. However, I think the neatest way is simply to flip the plot on its side. The `coord_flip()` command does exactly that:

```{r}
my_data %>%
  mutate(breakfast = str_to_sentence(breakfast),
         breakfast = fct_infreq(breakfast)) %>%
  ggplot(aes(x = breakfast)) +
  geom_bar(color = "black", fill = "grey") +
  labs(x = "Breakfast", y = "N") +
  theme_cowplot() +
  coord_flip()
```

I think this is a nice plot. If you really care about the small things and want the highest frequency categories to be at the top rather than bottom, you can introduce a `fct_rev()` comand into the pipeline after the `fct_infreq()` one. Again, because we're essentially changing the variable, the command needs to be inside `mutate()`:

```{r}
my_data %>%
  mutate(breakfast = str_to_sentence(breakfast),
         breakfast = fct_infreq(breakfast),
         breakfast = fct_rev(breakfast)) %>%
  ggplot(aes(x = breakfast)) +
  geom_bar(color = "black", fill = "grey") +
  labs(x = "Breakfast", y = "N") +
  theme_cowplot() +
  coord_flip()
```

Finally, we can visualise the age breakdown by breakfast choice using boxplots. To do this, you need to map each both of these variables onto one axis inside of the `aes()` function: The categorical variable belongs on the x axis and the continuous on the y axis:

```{r}
my_data %>%
  ggplot(aes(x = breakfast, y = age)) +
  geom_boxplot()
```

\ 

We can re-use essentially all the commands from our previous plot to make this boxplot by group a little nicer.

```{r}
my_data %>%
  mutate(breakfast = str_to_sentence(breakfast),
         breakfast = fct_rev(breakfast)) %>%
  ggplot(aes(x = breakfast, y = age)) +
  geom_boxplot(color = "black", fill = "grey") +
  labs(x = "Breakfast", y = "Age") +
  theme_cowplot() +
  coord_flip()
```

\ 

And that's pretty much all we can do with out data in the way of visualisation. There are many more plots `ggplot()` is capable of creating and many more ways in which to customise plots but, for the time boing, this is plenty.

### Write-up

Now that we are familiar with our data, we can start writing up. Obviously, we don'treally have any results yet but we can at least describe our sample. This is normally done in the *Participants* subsection of the *Method* section. On top of that, we can give a description of what data were collected and how in the *Materials* and *Procedure* subsections, respectively. Here, coth would be very shor so we can collapse them into a single subsection:

#### Method

##### Participants

Data from `r nrow(my_data)` first year Psychology students at the University of Sussex (*M*~age~ = `r age_desc %>% pull(mean)`, *SD*~age~ = `r age_desc %>% pull(sd)`) were collected anonymously in class as part of the Analysing Data module.

##### Materials and procedure

Participants filled in a questionnaire hosted via Google Forms. The form was accessed using a URL given in lecture. Each participant was given a unique ID code they then entered into the form. They also provided their age and information on what they had had for breakfast on the day. The latter was done by means of a multiple choice item and the response options available, along with age breakdown by response, are given in Table 1.

```{r, echo=F}
brekky_desc %>%
  mutate(breakfast = str_to_sentence(breakfast)) %>%
  kable(col.names = c("Breakfast", "*N*", "%", "*M*~age~", "*SD*~age~"),
        caption = "Table 1 *Descriptive statistics by breakfast*")
```

\ 

<div class="solText">
<title>Points to notice</title>

Read through our mock write-up again and notice the following points:

  - Concision
      - Make it short and sweet. Above, we only needed one sentence to tell the reader who our participants were, how many there were in our sample, what the basic descriptives of their age were, how they were recruited and where and how it all happened.
  - Right amount of detail
      - You want to report all the info about your sample that we did. If we knew the gender composition, we would also include it. We *could* also have reported the range of ages but it's not crucial.
      - In *Material and procedure* we need to give the reader enough information so that they get a good idea of what exactly it is that we did.
  - You can refer to tables and figures if it's helpful
      
These are all good guidelines for writing up the *Method* section.
</div>

\ 

That's all we have to cover this week. Over to you now!

## Worksheet

In the remaining time you will practice what you have just learnt. To make things interesting, let's use the data from the Gender and sexuality questionnaire we filled in in the lecture. You can find the data at https://...

`r task()`First of all, if you haven't done it yet, download the "01_basic_desc.Rmd" file from canvas and open it in R Studio.

Use the R Markdown file to complete the following tasks.

`r task()`In the `packages` code chunk, write the coad to load all the packages you will need to complete this practical: `tidyverse`, `knitr`, `stringr`, and `cowplot` should be enough.

`r task()`In the `read-in` code chunk, write the code to read the data into R Studio.

`r task()`In the `inspect` chunk, write code that does the following:

`r subtask()`Make sure the classes of your variables match the code book: Ordinal variables can be coded as numbers but categorical variables should be factors.

*Hint. *A basic summary will do.

`r subtask()`Check if all ID codes are unique.

`r task()`Take a minute to look at the summary of the data set. Notice the means and medians of the numeric variables. Think about what the distributions of the variables might look like.

`r task()`In the `descriptives` code chunk, write code that creates:

`r subtask()`A tibble of descriptive statistics (mean, standard deviation, minimum, maximum) for the `age` variable.

`r subtask()`A tibble with *N*s, %s, and age (mean and *SD*) breakdown by categories of the `gender` variable.

`r task()`In the `plots` code chunk, write code tat generates the following basic plots:

`r subtask()`A histogram of `age`:

```{r, echo = F}
# my_data %>%
#   ggplot(aes(x = age)) +
#   geom_histogram(bins = 8, color = "black", fill = "grey") +
#   theme_cowplot()
```

`r subtask()`A barchart of `gender`:

**ADD PLOT**

`r subtask()`A boxplot of `age` by `gender`:

**ADD PLOT**

`r task()`If you haven't formatted your plots yet, change the code in the chunk to generate prettier plots. If you want to, go mad with colours! [Here are some colour names you can use.](http://sape.inf.usi.ch/sites/default/files/ggplot2-colour-names.png)

`r task()`Complete the **Write-up** section of the .Rmd file.

`r task()`Edit the code in the `table_1` code chunk, giving it your tibble with age breakdown by gender, to create a nice formatted table in your document.

`r task()`Knit (generate) the final document from your R markdown file and rejoyce in its beauty.

\ 

That's all for this week. Well done!

\ 

\ 

