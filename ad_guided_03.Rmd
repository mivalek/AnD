---
title: "Guided practical 3"
author: "Analysing data"
---

## Today

<!-- To knit this .Rmd do the following -->

```{r setup_how_to_knit, include=F, eval=F}
remotes::install_github("mivalek/teachR")
teachR::slidify("[path to file]/ad_guided_03.Rmd", "other")
```

- Read in and check data
- Basic descriptive statistics
- Descriptive visualisation
- Write-up: Participants

## Guided part

```{r setup_data, echo = F}
set.seed(1)
library(tidyverse)
n <- 427
my_data <- tibble(id = replicate(n, paste(c(sample(LETTERS, 2, T), sample(0:9, 3)), collapse = "")),
                  age = round(abs(rnorm(n, 0, 2)) + 17.3),
                  breakfast = sample(c("sweet", "savoury", "only tea", "only cofee",
                                      "only other drink", "both sweet and savoury", "nothing"),
                                    n, replace = T, prob = c(.32, .14, .05, .21, .07, .11, .1)))
my_data[sample(n, 6), 2] <- NA
my_data[sample(n, 11), 3] <- NA
```

First of all, let's make sure we're all set up:

- Create a new R project in the AD folder, call it week_3
- Log into Canvas and go to this week's practical
- Download the "01_basic_desc.Rmd" file into your project folder
- Open R Studio

### Read in data

- Data from the form you filled in in the previous lecture are here: https://...
- We *could* download the file to our folder and then read it into R Studio
- However, we can also read it directly from the URL like this:

```{r, eval=F}
read_csv("https://...")
```

### Time to think

- Why might it be preferable to read data in from the URL?
- Why might it be better to save data on your computer?
- The `read_csv()` function comes from the `tidyverse` package. What do we need to do before we can run the command above?
- What will the command above do? Is that what we want? If not, what do we need to add to the line?


### Read in data

Let's read the data into R Studio so that we can start working with them

```{r, eval=F}
library(tidyverse)
my_data <- read_csv("https://...")
```

### First glance

- Now that we have our data in R Studio, we should familiarise ourselves with it
- Start by looking at the structure of the data set

```{r}
my_data %>% str()
```

### Categorical vars &rarr; factors

- Good to set categorical variables as factors
- Factors are handy for plotting and some statistics

```{r}
my_data <- my_data %>%
  mutate(id = factor(id), breakfast = factor(breakfast))
my_data %>% str()
```

### `summary()` 

Let's look at the roughest summary of our data

```{r}
my_data %>% summary()
```

### What to notice

- Missing values in the `age` and `breakfast`
  - Missing data happen, no reason to panic
- `id` was a required variable, we don't need to worry about `NA`s

### Sanity check

- `id` should be a unique code so it's good to check if there are no duplicates
- The `duplicated()` function takes a vector and returns a vector of `TRUE`s and `FLASE`s of equal length

```{r}
duplicated(c(1, 2, 5)) # unique -> all FALSE
duplicated(c(1, 2, 2)) # not unique -> some TRUE
```

### Sanity check

```{r}
my_data %>%
  mutate(id_check = duplicated(id)) %>%
  summary()
```

<aside class="notes" data-markdown>
Cool, there are only `FALSE`s which means no duplicates!

*Note. *We don't really need the `id_check` column permanently in our data set so we don't need to modify it by doing `my_data <- my_data %>% mutate(...`.
</aside>


### Basic descriptive stats

- We can now make tibbles of relevant summary statistics
- First of all, age

```{r}
age_desc <- my_data %>%
  summarise(age_mean = mean(age),
            sd_age = sd(age),
            min_age = min(age),
            max_age = max(age),
            na_age = sum(is.na(age)))
age_desc
```

### Time to think

- Why are we getting weird results?
- What do we need to do to get what we want?

### Remove `NA`s

```{r}
age_desc <- my_data %>%
  summarise(mean = mean(age, na.rm = T),
            sd = sd(age, na.rm = T),
            min = min(age, na.rm = T),
            max = max(age, na.rm = T),
            na = sum(is.na(age)))
age_desc
```

### Round up

<aside class="notes" data-markdown>
We only ever need to report these kinds of numbers to 2 decimal places so let's round things up.
</aside>

```{r}
age_desc <- age_desc %>% 
  modify(round, 2)
age_desc
```

### Use pipelines

We can doo all of the above in a single *pipeline*:

```{r}
age_desc <- my_data %>%
  summarise(mean = mean(age, na.rm = T),
            sd = sd(age, na.rm = T),
            min = min(age, na.rm = T),
            max = max(age, na.rm = T),
            na = sum(is.na(age))) %>%
  modify(round, 2)
age_desc
```

### Reporting

- This `age_desc` tibble enables us to report descriptive statistics in text
- We can just type "<code>&#96;r age_desc %>% pull(mean)&#96;</code>" in R Markdown
- Generated document will read "`r age_desc %>% pull(mean)`"

### More descriptives

- Tibble of age breakdown by breakfast

```{r, warning=T}
brekky_desc <- my_data %>%
  group_by(breakfast) %>%
  summarise(n = n(),
            perc = n()/nrow(my_data) * 100,
            mean_age = mean(age, na.rm = T),
            sd_age = sd(age, na.rm = T)) %>%
  modify_if(is.numeric, round, 2)
brekky_desc
```

### Warnings

The command returns the following warning:

"Factor `breakfast` contains implicit NA, consider using `forcats::fct_explicit_na`"

<aside class="notes" data-markdown>
This is not technically a problem, we can just have a row for `NA` in the tibble. However, using the `fct_explicit_na()` function suggested by the warning creates an additional level `(Missing)` in the `breakfast` variable, instead of the `NA`s.
</aside>

### Explicit `NA`s

- We can use the function inside of `mutate()`

```{r}
brekky_desc <- my_data %>%
  mutate(breakfast = fct_explicit_na(breakfast)) %>%
  group_by(breakfast) %>%
  summarise(n = n(),
            perc = n()/nrow(my_data) * 100,
            mean_age = mean(age, na.rm = T),
            sd_age = sd(age, na.rm = T)) %>%
  modify_if(is.numeric, round, 2)
brekky_desc
```

<aside class="notes" data-markdown>
I think this looks better and there are also minor advantages of having explicitly labelled missing data when it comes to plotting. More on that later...
</aside>

### Tables in documents

Tibbles can be turned into nice tables using `knitr::kable()`

```{r}
library(knitr)
brekky_desc %>% kable()
```

<aside class="notes" data-markdown>
Granted, the table isn't formatted perfectly... Let's do it then!

There are basically only three things we want to edit

1. It would be good to capitalise the first letters in each breakfast option
2. The table header could look better
3. The table should have a caption

With respect to the first point, we could laboriously change the first column of `brekky_desc`. Fortunately, there is a function in the `stringr` package that turns a string into a sentence, *i.e.,* capitalises the first letter:
</aside>

### Formatting

- To capitalise character stings, use `stringr::str_to_sentence()`

```{r}
library(stringr)
str_to_sentence("some string we want to edit")
```

### Formatting

We can use this function in `mutate()` to change the first column of our `brekky_desc` tibble

```{r}
brekky_desc %>%
  mutate(breakfast = str_to_sentence(breakfast))
```

<aside class="notes" data-markdown>
The remaining two edits can be done using arguments to `kable()`, namely `col.names=` and `caption=`. We can use R Markdown within these arguments to get things like subscripts or italics:
</aside>

### Formatting

```{r}
brekky_desc %>%
  mutate(breakfast = str_to_sentence(breakfast)) %>%
  kable(col.names = c("Breakfast", "*N*", "%", "*M*~age~", "*SD*~age~"),
        caption = "Table 1 *Descriptive statistics by breakfast*")
```


<aside class="notes" data-markdown>
Tables in documents generated from your own R markdown files will look slightly different. That is because we are using our own custom theme for these sheets.
</aside>

### Visualisation

- It's worth visualising your data using plots
- Some plots are great for presenting results, others are for you to get a better feel for your data and results
- Don't put every plot in your report
- Use appendix/supplementary materials

<aside class="notes" data-markdown>
While some descriptive statistics and results are best summarised in a table, it is often worth visualising your data using plots. Some plots are great for presenting results to your audience while others are just a tool for you to get a better feel for your data and results. It is neither necessary nor desirable to include every plot you create in your write-up/paper/poster. Only show plots if they add anything of explanatory value to your body text and tables, the rest are for your eyes only (or for the appendix/supplementary materials).
</aside>

### Histogram

Let's look at a simple histogram of our `age` variable

```{r, message=T}
my_data %>% ggplot(aes(x = age)) + geom_histogram()
```

<aside class="notes" data-markdown>

OK, this histogram gives us a visual representation of the distribution of ages in the sample: The vast majority of participants are 18-19 years old. This is not news as we can read this from the first summary we ran
</aside>

### Histogram

```{r}
my_data %>% summary()
```

<aside class="notes" data-markdown>
- 1^st^ quartile of `age` is 18 and 3^rd^ quartile is 19
  - At least the middle 50% of the sample's age falls within 18 and 19
- Seeing the distribution plotted is still useful!
</aside>

### Customising plots

- We can customise our plots to death and beyond!
- The `cowplot` package contains a nice clean theme for publication-style `ggplot()` plots
- Let's install it

```{r, eval=F}
install.packages("cowplot")
```

### Customising plots

- Once we load `cowplot`, we can add `theme_cowplot()` to our plot to make it look a little better

```{r, echo=F}
library(cowplot)
```

```{r, message=T}
my_data %>% ggplot(aes(x = age)) + geom_histogram() + theme_cowplot()
```

<aside class="notes" data-markdown>
- `R` warns us that the histogram plots values by default into 30 bins
- We only have 8 distincs ages (17-24)
</aside>

### Customising plots

- We can change the number of bins to 8 using the `bins=`
- We can also change the colours
  - `color=` for outline of the bars
  - `fill=` for colour of the bars themselves

### Customising plots

<br>

```{r}
my_data %>%
  ggplot(aes(x = age)) + geom_histogram(bins = 8, color = "black", fill = "grey") +
  theme_cowplot()
```

### Customising plots

- Let's give our axes proper labels

```{r}
my_data %>%
  ggplot(aes(x = age)) + geom_histogram(bins = 8, color = "black", fill = "grey") +
  labs(x = "Age", y = "Frequency") + theme_cowplot()
```

### Barchart

- We can plot a single categorical variable (`breakfast`) on a barchart

```{r}
my_data %>% ggplot(aes(x = breakfast)) + geom_bar()
```

### Order of bars

- Bars are ordered alphabetically
- Labels are the same as the levels of `breakfast` variable

```{r}
my_data %>%
  pull(breakfast) %>%
  levels()
```

### Make it pretty

- Capitalise x-axis labels (`str_to_sentence()`)
- Order levels of the variable according to frequency
  - Most popular breakfast option is on one end of the plot and the least popular on the other
  - Add the `fct_infreq()` function to the `mutate()` command


### Make it pretty

```{r}
my_data %>%
  mutate(breakfast = str_to_sentence(breakfast),
         breakfast = fct_infreq(breakfast)) %>%
  ggplot(aes(x = breakfast)) +
  geom_bar()
```

<aside class="notes" data-markdown>
- The two functions inside the `mutate()` commands come before the data are pushed into `ggplot()`
- We aren't really changing the plot itself but the `my_data` tibble.
- We're telling `R` to change the `breakfast` variable in the tibble so that its levels are capitalised and then change it again so that the levels are ordered according to their frequencies.
</aside>

### Make it pretty

Let's tweak the appearance of our plot using what we already know

### Make it pretty

```{r}
my_data %>%
  mutate(breakfast = str_to_sentence(breakfast),
         breakfast = fct_infreq(breakfast)) %>%
  ggplot(aes(x = breakfast)) + geom_bar(color = "black", fill = "grey") +
  labs(x = "Breakfast", y = "N") + theme_cowplot()
```

### Make it pretty

<aside class="notes" data-markdown>
- We have overlapping labels - That's not great
- There are several ways around this issue
    - Rotate the labels 45° to stop them from overlapping.
    - Flip the plot on its side. The `coord_flip()` command does exactly that
</aside>

```{r}
my_data %>%
  mutate(breakfast = str_to_sentence(breakfast),
         breakfast = fct_infreq(breakfast)) %>%
  ggplot(aes(x = breakfast)) + geom_bar(color = "black", fill = "grey") +
  labs(x = "Breakfast", y = "N") + theme_cowplot() + coord_flip()
```

### Plotting relationships

- We can visualise the age breakdown by breakfast choice using boxplots
- Need to map each variable on its own axis inside `aes()`
  - Categorical variable belongs on the x axis
  - Continuous on the y axis


### Plotting relationships

```{r}
my_data %>%
  ggplot(aes(x = breakfast, y = age)) +
  geom_boxplot()
```


### Plotting relationships

We can re-use essentially all the commands from our previous plot to make this boxplot by group a little nicer

### Plotting relationships

```{r}
my_data %>%
  mutate(breakfast = str_to_sentence(breakfast),
         breakfast = fct_rev(breakfast)) %>%
  ggplot(aes(x = breakfast, y = age)) + geom_boxplot(color = "black", fill = "grey") +
  labs(x = "Breakfast", y = "Age") + theme_cowplot() + coord_flip()
```


<aside class="notes" data-markdown>
And that's pretty much all we can do with out data in the way of visualisation. There are many more plots `ggplot()` is capable of creating and many more ways in which to customise plots but, for the time boing, this is plenty.
</aside>

### Write-up

- Even without results, we can start writing up the **Method** section
  - Contains subsections on *Participants*, *Materials*, and *Procedure* (and maybe others)
  
<aside class="notes" data-markdown>
Now that we are familiar with our data, we can start writing up. Obviously, we don'treally have any results yet but we can at least describe our sample. This is normally done in the *Participants* subsection of the *Method* section. On top of that, we can give a description of what data were collected and how in the *Materials* and *Procedure* subsections, respectively. Here, coth would be very shor so we can collapse them into a single subsection:
</aside>

### Participants

> Data from `r nrow(my_data)` first year Psychology students at the University of Sussex (*M*~age~ = `r age_desc %>% pull(mean)`, *SD*~age~ = `r age_desc %>% pull(sd)`) were collected anonymously in class as part of the Analysing Data module.

### Materials and procedure

> Participants filled in a questionnaire hosted via Google Forms. The form was accessed using a URL given in lecture. Each participant was given a unique ID code they then entered into the form. They also provided their age and information on what they had had for breakfast on the day. The latter was done by means of a multiple choice item and the response options available, along with age breakdown by response, are given in Table 1.

### Table 1

```{r, echo=F}
brekky_desc %>%
  mutate(breakfast = str_to_sentence(breakfast)) %>%
  kable(col.names = c("Breakfast", "*N*", "%", "*M*~age~", "*SD*~age~"),
        caption = "Table 1 *Descriptive statistics by breakfast*")
```

### Points to notice

- Concision
  - Make it short and sweet. Above, we only needed one sentence to tell the reader who our participants were, how many there were in our sample, what the basic descriptives of their age were, how they were recruited and where and how it all happened.

- Right amount of detail
  - You want to report all the info about your sample that we did. If we knew the gender composition, we would also include it. We *could* also have reported the range of ages but it's not crucial.
  - In *Material and procedure* we need to give the reader enough information so that they get a good idea of what exactly it is that we did.
      
- You can refer to tables and figures if it's helpful

### Over to you

[Click here for today's tasks](ad_practical_03.html#worksheet)
